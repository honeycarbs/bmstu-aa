\chapter{Аналитический раздел}\label{sec:analyth}
В данном разделе будут представлены сведения об организации конвейерной обработки данных и способы её оценки,  описан реализуемый алгоритм. 
\section{Конвейерные вычисления}\label{subsec:pipe}
Способ организации процесса в качестве вычислительного конвейера позволяет построить процесс, содержащий несколько независимых этапов\cite{pipeline}, на нескольких потоках. Выигрыш во времени достигается при выполнении нескольких задач за счет параллельной работы ступеней, вовлекая на каждом такте новую задачу или команду. 
Для контроля стадии используются три основные метрики, описанные ниже.
\begin{enumerate}
	\setlength{\itemsep}{1.2pt}
	\item Время процесса - это время, необходимое для выполнения одной стадии.
	\item Время выполнения - это время, которое требуется с момента, когда работа была выполнена на предыдущем этапе, до выполнения на текущем. 
	\item Время простоя - это время, когда никакой работы не происходит и линии простаивают. 
\end{enumerate}
Для того, чтобы время простоя было минимальным, стадии обработки должны быть одинаковы по времени в пределах погрешности. При возникновении ситуации, в которой время процесса одной из линий больше, чем время других в $N$ раз, эту линию стоит распараллелить на $N$ потоков. 

В зарубежной литературе\cite{pipe-eng} конвейерная обработка именуется как $pipeline$ (англ. - трубопровод) из - за аналогии со строительным трубопроводом, в котором вода льется в одном направлении, от одной части трубопровода к следующей.

\section{Алгоритм Бойера -- Мура -- Хорспула}
В качестве алгоритма, который будет декомпозирован на этапы для конвейерной обработки, был выбран алгоритм Бойера -- Мура -- Хорспула. Это упрощённый вариант алгоритма Бойера — Мура\cite{bmserach}, предназначенный для поиска подстроки в строке. 
Выбор алгоритма обусловлен возможностью деления на независимые этапы: 
\begin{enumerate}
	\item Создание словаря для шаблона по следующей формуле: 
	\begin{equation}\label{bmsearch}
 		\begin{array}{ll}
 			shift(pattern_i) = |string| - \\
 			- last\_position(c, pattern[1..|pattern| - 1])
 		\end{array}
	\end{equation}
	где $last\_position$ — последнее вхождение символа в строку, $pattern[a..b]$ -- операция взятия подстроки.
	\item Сопоставление шаблона строке согласно следующему правилу: \\ 
	Совмещение начала текста и шаблона, сравнение. Если все символы совпали с наложенными символами строки, значит, подстрока найдена, и поиск окончен. Иначе, шаблон сдвигается на несколько символов вправо.
\end{enumerate}
Смещение происходит согласно значению в словаре шаблона. Для символов, не вошедших в шаблон, величина смещения устанавливается равной длине шаблона.

Представленный алгоритм имеет два независимых этапа, каждый из которых может быть обработан конвейерной линией. В качестве третьего этапа предлагается генерировать случайные строки и извлекать из них подстроки.

\section{Вывод}\label{sec:analyth-summ}
В качетсве входных и выходных данных для конвейера с тремя линиями достаточно использовать размер очереди, обрабатываемой конвейером. Конвейер может быть реализован следующим способом:
\begin{enumerate}[label=Линия \arabic*., leftmargin=*]
	\setlength{\itemsep}{1pt}
	\item Генерация случайной строки и подстроки, которая содержится в сгенерированной строке.
	\item Создание словаря для шаблона по формуле \ref{bmsearch}.
	\item Сопоставление шаблона строке.
\end{enumerate}
Для оптимальной работы программы строки, генерируемые линией 1 будут иметь фиксированную длину. Это обеспечит меньший простой конвейерных линий. 
Для чистоты эксперимента генерируемая линией 1 подстрока обязательно будет содержаться в генерируемой той же линией строке.

Для анализа работы алгоритма, согласно критериям, описанным  в подразделе \ref{subsec:pipe},  для конвейера следует реализовать временные штампы в начале и завершении обработки каждой поступающей в очередь заявки.


